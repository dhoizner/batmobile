#pragma config(Sensor, in1,    steeringPot,    sensorPotentiometer)
#pragma config(Sensor, in2,    breakPedalPot,  sensorPotentiometer)
#pragma config(Sensor, in3,    gasPedalPot,    sensorPotentiometer)
#pragma config(Sensor, in4,    linearActuatorPot, sensorPotentiometer)
#pragma config(Sensor, in5,    shiftStickPosition, sensorAnalog)
#pragma config(Sensor, dgtl1,  shiftHighDio,   sensorDigitalIn)
#pragma config(Sensor, dgtl2,  shiftLowDio,    sensorDigitalIn)
#pragma config(Sensor, dgtl3,  shiftReverseDio, sensorDigitalIn)
#pragma config(Sensor, dgtl4,  driftDio,       sensorDigitalIn)
#pragma config(Sensor, dgtl5,  shiftGreenOut,  sensorDigitalOut)
#pragma config(Sensor, dgtl6,  shiftRedOut,    sensorDigitalOut)
#pragma config(Sensor, dgtl7,  shiftBlueOut,   sensorDigitalOut)
#pragma config(Motor,  port2,           rightFrontMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftFrontMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           rearMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           turnLinearActuator, tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define LINEAR_ACTUATOR_MID 1980
#define LINEAR_ACTUATOR_MAX_RIGHT 720
#define LINEAR_ACTUATOR_MAX_LEFT 3239

/*----------------------------------------------------------------------------------------------------*\
|*                            - Single Joystick Control with Thresholds -                             *|
|*                                      ROBOTC on VEX 2.0 Cortex                                      *|
|*                                                                                                    *|
|*  This program uses both the Left and the Right joysticks to run the robot using "tank control".    *|
|*  It also uses a threshold value to ignore low readings from the joystick.  This eliminates         *|
|*  "noise" from joysticks that have not returned exactly to (0,0) which is common.                   *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Ch1 is the X axis and Ch2 is the Y axis for the RIGHT joystick.                             *|
|*    2)  Ch3 is the Y axis and Ch4 is the X axis for the LEFT joystick.                              *|
|*    3)  'abs(z)' is the ABSOLUTE VALUE of 'z'.                                                      *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]              [Name]              [Type]              [Description]                   *|
|*    Motor - Port 2          rightMotor           VEX Motor           Right motor                    *|
|*    Motor - Port 3          leftMotor            VEX Motor           Left motor                     *|
\*----------------------------------------------------------------------------------------------------*/

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main ()
{
  int threshold = 10;   // helps to eliminate 'noise' from a joystick that isn't perfectly at (0,0)
                        // feel free to change this to match your needs.

  int testVar = 0;
  int testVar2 = 0;

  while(1 == 1)
  {
  	//int breakPedalValue = SensorValue[breakPedalPot];
  	//int gasPedalValue = SensorValue[gasPedalPot];

  /*
  	// Shifter
  	int shiftStickValue = SensorValue[shiftStickPosition];

  	// LED values on the digital outs are reversed for the shifter, 0 turns a color on,
  	// 1 turns it off.
  	if(800 > shiftStickValue && shiftStickValue > 700) {
  		// shifter in reverse
  		SensorValue[shiftRedOut] = 0;
  		SensorValue[shiftBlueOut] = 1;
  		SensorValue[shiftGreenOut] = 1;
  	}
  	else if(1550 > shiftStickValue && shiftStickValue > 1450) {
  		// shifter in high
  		SensorValue[shiftBlueOut] = 0;
  		SensorValue[shiftGreenOut] = 1;
  		SensorValue[shiftRedOut] = 1;
    }
    else if(1800 > shiftStickValue && shiftStickValue > 1700) {
    	// shifter in low
    	SensorValue[shiftGreenOut] = 0;
    	SensorValue[shiftBlueOut] = 1;
  		SensorValue[shiftRedOut] = 1;
    }
    */

    int linearActuatorPotValue = SensorValue[linearActuatorPot];
    int linearActuatorTicksPerOneJoystick = 10;
    int linearActuatorJoystickThreshold = 10;

  	int linearActuatorSetpointFromCenter = abs(vexRT[Ch4]) * linearActuatorTicksPerOneJoystick;
  	int linearActuatorSetpoint;
  	if(vexRT[Ch4] > linearActuatorJoystickThreshold) {
  		linearActuatorSetpoint = LINEAR_ACTUATOR_MID - linearActuatorSetpointFromCenter;
  		if(linearActuatorSetpoint < LINEAR_ACTUATOR_MAX_RIGHT) {
  			linearActuatorSetpoint = LINEAR_ACTUATOR_MAX_RIGHT;
  		}
  	}
  	else if(vexRT[Ch4] < -linearActuatorJoystickThreshold) {
  		linearActuatorSetpoint = LINEAR_ACTUATOR_MID + linearActuatorSetpointFromCenter;
  		if(linearActuatorSetpoint > LINEAR_ACTUATOR_MAX_LEFT) {
  			linearActuatorSetpoint = LINEAR_ACTUATOR_MAX_LEFT;
  		}
  	}
  	else {
  		linearActuatorSetpoint = LINEAR_ACTUATOR_MID;
  	}

  	int linearActuatorPotThreshold = 40; //20
  	//9.97 ticks per 1 joystick value
  	if(linearActuatorPotValue - linearActuatorSetpoint > linearActuatorPotThreshold) {
  		motor[turnLinearActuator] = 127; //75
  	}
  	else if(linearActuatorPotValue - linearActuatorSetpoint < -linearActuatorPotThreshold) {
  		motor[turnLinearActuator] = -127; //-75
  	}
  	else {
  		motor[turnLinearActuator] = 0;
  	}



    if(abs(vexRT[Ch3]) > threshold)         // If the left joystick is greater than or less than the threshold:
    {
      motor[leftFrontMotor]  = (vexRT[Ch3])/2;   // Left Joystick Y value / 2.
      testVar = 100;
    }
    else                                    // If the left joystick is within the threshold:
    {
      motor[leftFrontMotor]  = 0;                // Stop the left motor (cancel noise)
      testVar = 0;
    }

    if(abs(vexRT[Ch2]) > threshold)         // If the right joystick is greater than or less than the threshold:
    {
      motor[rightFrontMotor] = (vexRT[Ch2])/2;   // Right Joystick Y value / 2.
      testVar2 = 100;
    }
    else                                    // If the right joystick is within the threshold:
    {
      motor[rightFrontMotor] = 0;                // Stop the right motor (cancel noise)
      testVar2 = 0;
    }
  }
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
